## **Урок 13: Практичне використання TypeScript із Cypress**

### **Мета**

- Ознайомити з TypeScript та його перевагами у контексті тестування з Cypress.
- Налаштувати TypeScript у проекті Cypress.
- Писати та запускати тести Cypress з використанням TypeScript, застосовуючи типізацію та інтерфейси.
- Вивчити кращі практики організації TypeScript-файлів і підтримки типобезпечності у тестах.

---

### **Структурування контенту**

#### **A. Вступ до TypeScript**

1. **Що таке TypeScript?**
   - **Визначення:**  
     TypeScript — це статично типізований надмножина JavaScript, яка компілюється у чистий JavaScript. Він додає опціональні типи, інтерфейси та розширені інструменти поверх JavaScript.
   - **Ключові особливості:**
     - Статична перевірка типів: виявлення помилок на етапі компіляції.
     - Покращена підтримка IDE: вдосконалений IntelliSense, автозаповнення та вбудована документація.
     - Сучасні можливості JavaScript: підтримує ES6/ES7 й новіші, із зворотною сумісністю.

    ##### **1. Що означає "надмножина JavaScript"?**

    **Визначення:**
    - Надмножина — це мова, яка містить всі можливості іншої мови (у цьому випадку JavaScript) та додає свої власні.
      
    **Пояснення:**
    - **TypeScript — це надмножина JavaScript:**  
      Це означає, що будь-який правильний код JavaScript є також правильним кодом TypeScript. TypeScript додає нові можливості (наприклад, статичні типи, інтерфейси, enum), які відсутні у звичайному JavaScript.
    - **Чому це важливо:**  
      Розробники можуть поступово впроваджувати TypeScript, додаючи типи та інші розширення до свого JavaScript-коду, не переписуючи все з нуля.

    
    ##### **2. Що таке компілятор?**

    **Визначення:**
    - Компілятор — це програма, яка транслює код, написаний однією мовою програмування (вихідна мова), в іншу (цільову мову). Для TypeScript, компілятор (tsc) перетворює TypeScript-код у чистий JavaScript.

    **Пояснення:**
    - **Компілятор TypeScript (tsc):**  
      Він виконує перевірку типів і перетворює розширений синтаксис TypeScript на стандартний JavaScript, який можна запускати у браузері або Node.js.
    - **Роль у розробці:**  
      Компілятор дозволяє виявляти помилки типів ще до виконання коду, що підвищує якість коду.


2. **Переваги використання TypeScript з Cypress:**
   - **Підвищена якість коду:**  
     Перевірка типів допомагає виявляти баги ще на етапі розробки.
   - **Кращий досвід розробника:**  
     Багатий IntelliSense та автозаповнення у редакторах, таких як VS Code, прискорюють написання тестів і зменшують помилки.
   - **Покращене супроводження:**  
     Чіткі визначення типів та інтерфейсів роблять код розбірливішим і полегшують рефакторинг.
   - **Масштабованість:**  
     Зі зростанням набір тестів сильна типізація допомагає підтримувати узгодженість та зменшувати кількість помилок під час виконання.

---

#### **B. Налаштування TypeScript у Cypress**

1. **Встановлення TypeScript та необхідних типів:**
   - **Команди для встановлення:**
     ```bash
     npm install --save-dev cypress typescript @types/node
     ```
   - **Навіщо ці пакунки?**
     - `typescript`: Компілятор TypeScript.
     - `@types/node`: Опис типів для Node.js, необхідний для Cypress-завдань та Node API.

2. **Налаштування tsconfig.json для Cypress:**
   - Створіть файл `tsconfig.json` у корені проекту, якщо його ще немає.
   - **Приклад tsconfig.json:**
     ```json
     {
        "compilerOptions": {
          "target": "ES2020",
          "module": "ESNext",
          "lib": ["ES2020", "DOM", "DOM.Iterable"],
          "allowJs": false,
          "skipLibCheck": true,
          "esModuleInterop": false,
          "allowSyntheticDefaultImports": true,
          "strict": true,
          "forceConsistentCasingInFileNames": true,
          "moduleResolution": "node",
          "resolveJsonModule": true,
          "isolatedModules": true,
          "noEmit": true,
          "types": ["cypress", "node"]
        },
        "include": [
          "cypress/**/*.ts",
          "cypress/**/*.tsx"
        ],
        "exclude": ["node_modules"]
      }
     ```
   - **Пояснення:**
     - **`target`** and **`module`**: Гарантують генерацію сучасного JavaScript.
     - **`strict`**: Увімкнено жорстку перевірку типів.
     - **`types`**: Підключає визначення типів Cypress та Node.
     - **`include`**: Дозволяє TypeScript компілювати ваші тестові файли з папки Cypress.

---

#### **C. Написання Cypress-тестів на TypeScript**

1. **Перетворення JavaScript-тестів на TypeScript:**
   - Змініть розширення тестових файлів з `.js` на `.ts`.
   - Використовуйте типізацію там, де це доречно, наприклад:
     ```typescript
     describe('User Login', () => {
       it('should log in successfully with valid credentials', () => {
         cy.visit('/login');
         cy.get('[data-testid="login-username-input"]').type('demoUser');
         cy.get('[data-testid="login-password-input"]').type('demoPass');
         cy.get('[data-testid="login-submit-button"]').click();
         cy.get('[data-testid="login-success-message"]').should('be.visible');
       });
     });
     ```
   - Зверніть увагу, що команди Cypress працюють бездоганно завдяки визначенням з `@types/cypress`.

2. **Використання типізації та інтерфейсів:**
   - **Визначення інтерфейсу:**  
     Використовуйте інтерфейси для опису структури об'єктів, які очікуєте у тестах.
     ```typescript
     interface User {
       username: string;
       email: string;
       password: string;
     }
     ```
   - **Використання інтерфейсу:**
     ```typescript
     const validUser: User = {
       username: 'demoUser',
       email: 'demo@example.com',
       password: 'demoPass'
     };

     describe('User Login with TypeScript', () => {
       it('should log in successfully using a User object', () => {
         cy.visit('/login');
         cy.get('[data-testid="login-username-input"]').type(validUser.username);
         cy.get('[data-testid="login-password-input"]').type(validUser.password);
         cy.get('[data-testid="login-submit-button"]').click();
         cy.get('[data-testid="login-success-message"]').should('be.visible');
       });
     });
     ```

     
    ##### **Різниця між типами (types) та інтерфейсами (interfaces)**

    **Інтерфейси:**
    - **Призначення:**  
      Визначають структуру об'єкта. Головним чином використовуються для опису вигляду об'єкта.
    - **Можливості:**  
      - Можуть розширюватись (успадкування).
      - Об'єднують оголошення (declaration merging).
      - Найкраще підходять для визначення контрактів у коді.
    - **Приклад:**
      ```typescript
      interface User {
        username: string;
        email: string;
        age?: number; // Необов’язкова властивість
      }
      ```

    **Типи (types):**
    - **Призначення:**  
      Псевдоніми типів можуть визначати типи для об'єктів, примітивів, об'єднань (unions), перетинів (intersections) та ін.
    - **Можливості:**  
      - Гнучкіше за інтерфейси.
      - Дозволяють визначати об'єднання, перетини, або примітивні типи.
      - Не підтримують об'єднання оголошень.
    - **Приклад:**
      ```typescript
      type User = {
        username: string;
        email: string;
        age?: number;
      };

      type Response = User | null; // Приклад Union type
      ```

    **Коли використовувати:**  
    - Використовуйте **інтерфейси**, коли потрібно визначити структуру об'єкта і, можливо, розширювати її пізніше.  
    - Використовуйте **типи**, коли потрібна гнучкість (наприклад, об'єднання типів або складні композиції).

    ##### **Що таке Enum та як їх використовувати з Cypress**

    **Визначення:**
    - **Enum (перерахування):**  
      Enum дозволяє визначити набір іменованих констант. Вони допомагають зробити код читабельнішим і легше підтримувати, даючи осмислені імена числовим або строковим значенням.

    **Приклад використання:**
    - У тесті Cypress можна використати enum для визначення ролей користувачів або стану додатку.
      
    **Приклад на TypeScript:**
    ```typescript
    enum UserRole {
      Admin = 'admin',
      User = 'user',
      Guest = 'guest'
    }

    // Використання у тесті чи page object
    const currentUserRole: UserRole = UserRole.Admin;
    cy.log(`Current User Role: ${currentUserRole}`);
    ```

    **Переваги:**  
    - Покращує читабельність, замінюючи літеральні стрічки або числа осмисленими іменами.
    - Дозволяє забезпечити використання лише дозволених значень, завдяки перевірці типів.



    ##### **Що таке файли з суфіксом .d.ts**

    **Визначення:**
    - **Файли .d.ts (Declaration Files / Файли оголошень):**  
      Це оголошення типів для JavaScript-модулів, які не мають своїх власних типів. Вони допомагають компілятору TypeScript зрозуміти структуру використовуваних бібліотек або API.

    **Використання:**
    - Зазвичай розміщують у папці `types` або поруч із пакетами, для яких нема типізації TypeScript.
    - Оголошують інтерфейси, типи та модулі без надання реалізації.
      
    **Приклад:**
    ```typescript
    // custom-types.d.ts
    declare module 'my-legacy-library' {
      export function doSomething(input: string): number;
    }
    ```

    **Перевага:**  
    - Дозволяє інтегрувати звичайні JavaScript-бібліотеки у проект на TypeScript із правильною перевіркою типів та підтримкою IntelliSense.


3. **Використання IntelliSense та перевірки типів:**
   - З TypeScript ваш IDE (наприклад, VS Code) надає підказки в реальному часі, автозаповнення та перевірку помилок.
   - Це робить написання і налагодження тестів ефективнішими та менш схильними до помилок.

---

#### **D. Кращі практики використання TypeScript в Cypress**

1. **Організація TypeScript-файлів:**
   - Усі тестові файли Cypress зберігайте з розширенням `.ts`.
   - Організуйте ваші тести у директоріях на кшталт `cypress/e2e` і переконайтесь, що шляхи цих папок включені в `tsconfig.json`.
   - Перевикористовувані типи та інтерфейси зберігайте у окремому файлі (наприклад, `cypress/support/types.ts`).

2. **Підтримка типобезпечності:**
   - Завжди використовуйте суворий режим (`"strict": true`) у `tsconfig.json`.
   - Використовуйте інтерфейси й типи для тестових даних, конфігураційних об'єктів і кастомних команд.
   - Уникайте використання `any`, якщо це не є необхідністю.

3. **Пишіть зрозумілий і модульний код:**
   - Розбивайте тестову логіку на менші та керовані функції або кастомні команди.
   - Використовуйте паттерн Arrange-Act-Assert (AAA) для структурування тестів.

4. **Використання кастомних команд у TypeScript:**
   - Оголошуйте кастомні команди у TypeScript-файлі (наприклад, `cypress/support/commands.ts`).
   - Вказуйте типи параметрів та значень, які повертаються, для кращої перевірки типів та підтримки IntelliSense.
   - **Приклад кастомної команди на TypeScript:**
     ```typescript
      export { }
        declare global {
          namespace Cypress {
            interface Chainable {
              login(name: string, password: string): Chainable<void>
            }
          }
        }

      Cypress.Commands.add('login', (username: string, password: string) => {
        cy.get('[data-testid="login-username-input"]').clear().type(username);
        cy.get('[data-testid="login-password-input"]').clear().type(password);
        return cy.get('[data-testid="login-submit-button"]').click();
      });
     ```

    
    **Визначення типів, що повертаються**
    - Типи, що повертаються у TypeScript, явно вказують тип значення, яке повертає функція.

    **Використання:**
    - Вказівка типу, що повертається, допомагає знаходити помилки, коли реалізація функції не збігається з оголошеним типом результату.
      
    **Приклад:**
    ```typescript
    function sum(a: number, b: number): number {
      return a + b;
    }

    const result: number = sum(5, 7);
    ```

     
    ##### **Що таке ```Chainable<void>``` та ```Chainable<Element>```**

    **Визначення:**
    - У Cypress команди повертають об'єкт `Chainable`, який дозволяє об'єднувати (ланцюжити) декілька команд.

    **Chainable<void>:**
    - Означає, що команда повертає chainable-об'єкт, який не повертає конкретний елемент.  
    - Зазвичай використовується для команд, які виконують дію (наприклад, клік), але не повертають DOM-елемент.
      
    **Приклад:**
    ```typescript
    cy.get('[data-cy="login-button"]').click();
    // click() повертає Chainable<void>, бо не повертає значення.
    ```

    **Chainable<Element>:**
    - Означає, що команда повертає chainable-об'єкт, який повертає DOM-елемент(и).  
    - Корисно, коли потрібно далі виконувати дії або перевірки з вибраним елементом.
      
    **Приклад:**
    ```typescript
    cy.get('[data-cy="login-username-input"]').should('be.visible');
    // get() повертає Chainable<Element>, бо повертає DOM-елемент.
    ```

    **Чому це важливо:**
    - Розуміння цих типів допомагає знати, чого очікувати при ланцюжінні команд та сприяє написанню типобезпечних тестів з підтримкою IntelliSense.


     ### **6. Переваги та недоліки використання TypeScript з Cypress**

    **Переваги:**
    - **Раннє виявлення помилок:**  
      Типізація знаходить помилки ще під час розробки до виконання тестів.
    - **Кращий досвід розробника:**  
      Багатий IntelliSense, автозаповнення та документація спрощують написання тестів.
    - **Покращене супроводження:**  
      Явні типи та інтерфейси полегшують розуміння та рефакторинг коду.
    - **Масштабованість:**  
      У міру зростання набору тестів типобезпечність допомагає керувати складністю та запобігати багам.

    **Недоліки:**
    - **Початкові трудові витрати:**  
      Налаштування TypeScript у існуючому проекті потребує часу та конфігурації.
    - **Крива навчання:**  
      Новачки мають освоїти концепції TypeScript і його синтаксис.
    - **Крок компіляції:**  
      TypeScript додає додатковий крок компіляції, що може дещо сповільнити зворотній зв’язок порівняно з простим JavaScript.
    - **Ризик надмірного ускладнення:**  
      Для дуже маленьких проектів додаткова складність TypeScript може бути невиправданою.

---

#### **E. Діяльності**

1. **Налаштуйте TypeScript у своєму Cypress-проекті:**
   - Ініціалізуйте проект на Vue або Vite (якщо його ще не створено).
   - Встановіть TypeScript і необхідні типи.
   - Створіть та налаштуйте `tsconfig.json`, щоб включити файли Cypress.
   - Перетворіть існуючий тест JavaScript на TypeScript.

2. **Напишіть і запустіть простий Cypress-тест на TypeScript:**
   - Створіть файл тесту (наприклад, `cypress/e2e/login.spec.ts`) з використанням типізації та інтерфейсів.
   - Використовуйте кастомні команди, написані на TypeScript, для виконання дії входу.
   - Запустіть тест і спостерігайте за роботою IntelliSense та перевіркою типів.

3. **Відрефакторьте існуючі тести:**
   - Визначте частини тестового коду, де можна додати типізацію для ясності.
   - Замініть використання `any` на відповідні інтерфейси чи типи.

---

### **Потенційні питання студентів і відповіді**

1. **Q:** *Що таке TypeScript і чому він корисний для тестів Cypress?*  
   **A:** TypeScript — це статично типізований надмножина JavaScript, яка допомагає знаходити помилки ще на етапі компіляції. Він підвищує якість коду, забезпечує кращий IntelliSense і автозаповнення, а також покращує супроводжуваність та масштабованість тестів завдяки перевірці типів.

2. **Q:** *Чи потрібно мені конвертувати всі мої тести Cypress у TypeScript?*  
   **A:** Ні, але використання TypeScript може бути дуже корисним, особливо при розширенні набору тестів. Ви можете почати з кількох найважливіших тестів і поступово переводити інші, коли зросте досвід роботи з TypeScript.

3. **Q:** *Як працюють змінні середовища з TypeScript у Cypress?*  
   **A:** Змінні середовища доступні через `import.meta.env` у Vite. TypeScript буде сприймати їх як рядки, якщо не вказати власні типи, тому важливо явно приводити їх до потрібного типу (наприклад, використовуючи `Number()` для числових значень).

4. **Q:** *Які основні переваги використання кастомних команд у TypeScript?*  
   **A:** Кастомні команди дозволяють інкапсулювати повторювані дії, зменшити дублювання коду та створювати більші абстракції. У TypeScript вони надають типобезпечність, полегшуючи підтримку та налагодження тестів.

5. **Q:** *Як організувати TypeScript-файли для тестування Cypress?*  
   **A:** Рекомендовано зберігати тести у `cypress/e2e` (з розширенням `.ts`), а кастомні команди, типи, та page objects — у `cypress/support`. Добре організована структура допомагає підтримувати зрозумілість та масштабованість проекту.

1. **Q:** *Що означає, що TypeScript — це "надмножина" JavaScript?*  
   **A:** Це означає, що весь правильний JavaScript-код є також правильним TypeScript-кодом. TypeScript додає додаткові можливості, такі як статичні типи та інтерфейси, підвищуючи якість коду без порушення сумісності з існуючим JavaScript.

2. **Q:** *Що таке компілятор і як він працює з TypeScript?*  
   **A:** Компілятор — це інструмент, що транслює код з однієї мови в іншу. Компілятор TypeScript (`tsc`) перетворює TypeScript-код у чистий JavaScript, перевіряючи типи і забезпечуючи сумісність з браузером чи Node.js.

3. **Q:** *Яка різниця між типами (types) та інтерфейсами (interfaces) у TypeScript?*  
   **A:** Обидва визначають структуру даних. Інтерфейси здебільшого використовуються для опису структури об’єктів і підтримують об’єднання оголошень, тоді як псевдоніми типів гнучкіші, можуть описувати об’єднання, перетини і навіть примітиви. Інтерфейси — для об’єктів, типи — для складних композицій.

4. **Q:** *Як працюють enum у TypeScript і навіщо вони у Cypress-тестах?*  
   **A:** Enum дозволяє визначати набір іменованих констант. Вони підвищують читабельність і полегшують підтримку, замінюючи літеральні значення на осмислені імена. У Cypress-тестах enum використовують для керування статус-кодами, ролями користувачів чи іншими фіксованими наборами значень.

5. **Q:** *Що таке .d.ts-файли і навіщо вони потрібні?*  
   **A:** Файли оголошень (.d.ts) надають типову інформацію про JavaScript-бібліотеки, які не мають типізованого опису TypeScript. Вони дозволяють компілятору TypeScript розуміти зовнішні модулі, забезпечуючи коректну перевірку типів та підтримку IntelliSense.

6. **Q:** *Які переваги та недоліки TypeScript у Cypress?*  
   **A:** Переваги: раннє виявлення помилок, кращий досвід розробника і покращена супроводжуваність завдяки типам. Недоліки: початкові трудові витрати, крива навчання, додатковий крок компіляції, що може трохи сповільнити розробку.

7. **Q:** *Що таке типи, що повертаються у TypeScript, і чому ними треба користуватись?*  
   **A:** Типи, що повертаються, явно вказують тип значення, яке поверне функція, забезпечуючи правильність результату. Це збільшує зрозумілість і допомагає виявляти помилки на етапі компіляції.

8. **Q:** *Що означає Chainable<void> і Chainable<Element> у Cypress?*  
   **A:** `Chainable<void>` означає, що команда Cypress повертає chainable-об'єкт без DOM-елементу (наприклад, дії типу click), а `Chainable<Element>` — повертає DOM-елемент, з яким можна далі працювати чи робити перевірки.

---

### **Ресурси**

- **Документація TypeScript з Cypress:**  
  [Cypress TypeScript Support](https://docs.cypress.io/guides/tooling/typescript-support)
- **Офіційна документація TypeScript:**  
  [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- **Приклади Cypress:**  
  Шукайте open-source проекти на GitHub, які демонструють використання TypeScript із Cypress.